from collections import defaultdict, Counter
from itertools import product
import logging

# Generated by script in extract-ud2gf-cat-labels.py and data from the ud2gf UDTranslate.labels
POSSIBLE_GF_CATS_BY_UD_CAT = defaultdict(list, {'NOUN': ['N'],
                                 'PROPN': ['PN'],
                                 'ADJ': ['A', 'AdA'],
                                 'VERB': ['V', 'V2', 'V3', 'VV', 'VA', 'VS', 'VQ', 'V2V', 'V2A', 'V2S', 'V2Q'],
                                 'AUX': ['VV'],
                                 'ADV': ['AdA', 'AdN', 'AdV', 'Adv', 'IAdv', 'Subj'],
                                 'CONJ': ['Conj'],
                                 'PRON': ['Pron', 'NP', 'Det', 'IP'],
                                 'DET': ['Predet', 'Det', 'IDet', 'Quant', 'IQuant'],
                                 'INTJ': ['Interj'],
                                 'ADP': ['Prep'],
                                 'SCONJ': ['Subj']})


class BigramFeatures:
    def __init__(self, fields):
        self.node_lemma     = fields[0]
        self.node_upostag   = fields[1]
        self.deprel         = fields[2]
        if (self.deprel == 'root'):
            assert(len(fields) == 3)
            self.head_lemma     = 'root'
            self.head_upostag   = 'root'
        else:
            assert(len(fields) == 5)
            self.head_lemma     = fields[3]
            self.head_upostag   = fields[4]

def read_feature_counts(path):
    with open(path, mode='r', encoding='utf-8') as file:
        parse_errors = 0
        for l in file:
            l_split = l.split()
            count = int(l_split[0])
            feat = l_split[1:]
            try:
                yield (BigramFeatures(feat), count)
            except AssertionError:
                parse_errors += 1
        if parse_errors:
            logging.warning('Badly structured lines: ' + str(parse_errors))


def read_possibility_dictionary(path):
    from ast import literal_eval
    with open(path, mode='r', encoding='utf-8') as f:
        return dict(literal_eval(l) for l in f)


def parse_languages(languages, feature_count_files, poss_dict_files):
    features = dict()
    for lang in languages:
        logging.info("Parsing {}.".format(lang))
        poss_dict = defaultdict(lambda: [], read_possibility_dictionary(poss_dict_files[lang]))
        feature_counts = read_feature_counts(feature_count_files[lang])
        possibility_counts = ((possible_bigrams(poss_dict, feature), count) 
                                for feature, count in feature_counts)
        # Add results to dictionary
        features[lang] = Counter(dict(possibility_counts))
    return features


def possible_bigrams(poss_dict, feature):
    possible_node_funs = possible_functions(poss_dict, 
                            lemma=feature.node_lemma,
                            ud_cat=feature.node_upostag)
    possible_head_funs = possible_functions(poss_dict, 
                            lemma=feature.head_lemma,
                            ud_cat=feature.head_upostag)
    return frozenset(product(possible_node_funs, possible_head_funs))


def possible_functions(poss_dict, lemma, ud_cat):
    if lemma == 'root':
        return ['ROOT']
    possible_categories = POSSIBLE_GF_CATS_BY_UD_CAT[ud_cat]
    possible_functions = [gf_function for cat in possible_categories
                          for gf_function in poss_dict[(lemma, cat)]]

    return possible_functions if len(possible_functions) > 0 else ['OOV_' + ud_cat]