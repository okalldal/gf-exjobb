from collections import defaultdict, Counter
from itertools import product
import logging

# Generated by script in extract-ud2gf-cat-labels.py and data from the ud2gf UDTranslate.labels
POSSIBLE_GF_CATS_BY_UD_CAT = defaultdict(list, {'NOUN': ['N'],
                                 'PROPN': ['PN'],
                                 'ADJ': ['A', 'AdA'],
                                 'VERB': ['V', 'V2', 'V3', 'VV', 'VA', 'VS', 'VQ', 'V2V', 'V2A', 'V2S', 'V2Q'],
                                 'AUX': ['VV'],
                                 'ADV': ['AdA', 'AdN', 'AdV', 'Adv', 'IAdv', 'Subj'],
                                 'CONJ': ['Conj'],
                                 'PRON': ['Pron', 'NP', 'Det', 'IP'],
                                 'DET': ['Predet', 'Det', 'IDet', 'Quant', 'IQuant'],
                                 'INTJ': ['Interj'],
                                 'ADP': ['Prep'],
                                 'SCONJ': ['Subj']})



def parse_counts(feature_count_file, poss_dict, count_col, feature_cols, delimiter='\t'):
    counts = dict()
    with open(feature_count_file, mode='r', encoding='utf-8') as file:
        for l in file:
            l_split = l.split(delimiter)
            count = int(l_split[count_col])
            feature = tuple([l_split[i] for i in feature_cols])
            if feature in poss_dict.keys():
                counts[feature] = counts[feature] + count if feature in counts.keys() else count
    return list(counts.items())

def read_feature_counts(path):
    with open(path, mode='r', encoding='utf-8') as file:
        for l in file:
            l_split = l.split('\t')
            yield (tuple(l_split[:-1]), int(l_split[-1]))

def unigram_features(full_feature):
    return full_feature[0]

def possible_bigrams(poss_dict, feature):
    possible_node_funs = possible_functions(poss_dict, feature[0], feature[2])
    if len(feature) > 4:
        possible_head_funs = possible_functions(poss_dict, feature[4], feature[6])
    else:
        possible_head_funs = ['ROOT']
    return frozenset(product(possible_node_funs, possible_head_funs))


def possible_functions(poss_dict, lemma, ud_cat):
    possible_categories = POSSIBLE_GF_CATS_BY_UD_CAT[ud_cat]
    possible_functions = [gf_function for cat in possible_categories
                          for gf_function in poss_dict[(lemma, cat)]]

    return possible_functions if len(possible_functions) > 0 else ['OOV_' + ud_cat]